<!DOCTYPE html>
<html lang="bg">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Iterator Pattern - Поведенчески Шаблони</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container">
      <aside class="sidebar">
        <h2>Съдържание</h2>
        <nav>
          <ul>
            <li><a href="index.html" class="nav-link">Начало</a></li>
            <li><a href="command.html" class="nav-link">Command</a></li>
            <li><a href="iterator.html" class="nav-link active">Iterator</a></li>
            <li><a href="observer.html" class="nav-link">Observer</a></li>
          </ul>
        </nav>
      </aside>

      <main class="main-content">
        <h1>Iterator Pattern</h1>

        <h2>Цел</h2>
        <p>
          <strong>Iterator</strong> е поведенчески шаблон, който ни позволява да обхождаме
          елементите на една колекция, <strong>без да разкриваме вътрешната ѝ структура</strong> -
          независимо дали представлява списък, стек, дърво или друг вид контейнер.
        </p>

        <div class="image-center">
          <img src="img/iterator/iterator-intent.png" alt="Iterator Intent Diagram" />
        </div>

        <h2>Проблем</h2>
        <p>
          Колекциите са едни от най-често използваните структури от данни в програмирането. По
          своята същност те представляват контейнери, които съхраняват групи от елементи.
        </p>

        <p>
          Някои колекции използват прости списъци, но други са изградени върху структури като
          стекове, дървета, графи и различни по-сложни организации на данни.
        </p>

        <div class="image-center">
          <img src="img/iterator/problem1.png" alt="Iterator problem1 Diagram" />
        </div>

        <p>
          Независимо от тяхната вътрешна структура, всяка колекция трябва да предоставя начин да
          достигаме до нейните елементи, така че останалата част от програмата да може да ги
          използва. Трябва да има възможност да обхождаме елементите последователно, без да ги
          повтаряме и без да знаем как точно са подредени вътрешно.
        </p>

        <p>
          При колекция, базирана на списък, задачата изглежда тривиална - просто правим цикъл. Но
          какво се случва, ако трябва да обходим дърво? Понякога ни е нуженo обхождане в дълбочина,
          друг път обхождане в широчина, а понякога дори произволен достъп до елементите.
        </p>

        <div class="image-center">
          <img src="img/iterator/problem2.png" alt="Iterator problem2 Diagram" />
        </div>

        <div class="md-highlight">
          <p>
            Когато добавим множество различни алгоритми за обхождане директно в самата колекция,
            нейната основна отговорност се размива.
            <strong
              >Тя трябва да се грижи за ефективно съхранение на данните, а не да поддържа специфични
              обхождания. Освен това, някои алгоритми може да са съобразени с конкретно приложение,
              така че добавянето им в една универсална (generic) колекция би било странно и
              неуместно.</strong
            >
          </p>
        </div>

        <p>
          От друга страна, клиентският код, който работи с колекциите, често няма интерес как точно
          са реализирани те. Но тъй като различните колекции предоставят различни начини за достъп
          до елементите си, клиентският код се оказва тясно свързан с конкретните класове на тези
          колекции.
        </p>

        <h2>Решение</h2>
        <p>
          Основната идея на шаблона <strong>Iterator</strong> е да извади поведението за обхождане
          на дадена колекция в отделен обект, наречен <em>итератор</em>.
        </p>

        <p>
          Итераторите могат да реализират различни алгоритми за обхождане - последователно, обратно,
          по дървовидна структура и други. Това позволява няколко итератора да обхождат една и съща
          колекция едновременно и напълно независимо един от друг.
        </p>

        <p>
          Освен алгоритъма, итераторът капсулира всички детайли по обхождането - текуща позиция,
          колко елемента остават и как да се премине към следващия. Клиентският код просто извиква
          метод за вземане на следващ елемент, докато не се достигне край.
        </p>

        <p>
          Всички итератори следват един и същ интерфейс. Това позволява клиентският код да работи с
          всякакви колекции и всякакви алгоритми за обхождане, стига да съществува подходящ
          итератор. Ако е необходим нов тип обхождане, просто се създава нов клас Iterator - без
          промени в колекцията или клиентския код.
        </p>

        <div class="image-center">
          <img src="img/iterator/solution1.png" alt="Iterator solution1 Diagram" />
        </div>

        <h2>Аналогия от Реалния Свят</h2>
        <p>
          Нека си представим, че искаме да посетим Рим за няколко дни и да обходим всички негови
          основни забележителности. Но когато пристигнем, лесно можем да изгубим часове в лутане,
          въртейки се в кръг, без дори да намерим Колизеума.
        </p>

        <p>
          Вместо това бихме могли да използваме приложение-гид на телефона си. То е евтино, удобно и
          ни позволява да се придвижваме уверено из града, спирайки колкото време пожелаем на всяко
          интересно място.
        </p>

        <p>
          Има и трети вариант - да наемем местен екскурзовод, който познава всяка уличка. Той може
          да съобрази маршрута с нашите предпочитания, да ни разведе из всички забележителности и да
          разказва увлекателни истории. Това е най-приятното, но и най-скъпото решение.
        </p>

        <div class="image-center">
          <img src="img/iterator/iterator-comic-1.png" alt="Iterator Real-World Diagram" />
        </div>

        <p>
          Всички тези опции - хаотичните посоки, които сами си измисляме, приложението-гид или
          екскурзоводът - играят ролята на <strong>итератори</strong> върху огромната „колекция“ от
          забележителности, които Рим предлага.
        </p>

        <h2>Структура</h2>
        <div class="cards-container">
          <!-- Iterator Interface -->
          <div class="card">
            <h3>1. Интерфейс Iterator</h3>
            <p>
              Декларира основните операции за обхождане на колекция – вземане на следващ елемент,
              проверка дали има още, връщане на текущата позиция и други.
            </p>
            <pre><code>
interface Iterator:
    hasNext()
    next()
    current()
    reset()
    </code></pre>
          </div>

          <!-- Concrete Iterator -->
          <div class="card">
            <h3>2. Конкретен Итератор (Concrete Iterator)</h3>
            <p>
              Реализира конкретен алгоритъм за обхождане. Сам следи позицията и позволява няколко
              итератора да работят върху една и съща колекция едновременно.
            </p>
            <pre><code>
class ConcreteIterator implements Iterator:
    collection
    position = 0

    constructor(collection):
        this.collection = collection

    hasNext():
        return position < collection.count()

    next():
        item = collection.get(position)
        position++
        return item

    current():
        return collection.get(position)

    reset():
        position = 0
    </code></pre>
          </div>

          <!-- Collection Interface -->
          <div class="card">
            <h3>3. Интерфейс Collection</h3>
            <p>
              Декларира методи за създаване на итератори, които са съвместими с конкретната
              колекция.
            </p>
            <pre><code>
interface Collection:
    createIterator()
    </code></pre>
          </div>

          <!-- Concrete Collection -->
          <div class="card">
            <h3>4. Конкретна Колекция (Concrete Collection)</h3>
            <p>
              Съхранява елементите и връща нов обект на Конкретния Итератор при всяко извикване на
              <code>createIterator()</code>.
            </p>
            <pre><code>
class ConcreteCollection implements Collection:
    items[]

    add(item):
        items.append(item)

    get(i):
        return items[i]

    count():
        return length(items)

    createIterator():
        return new ConcreteIterator(this)
    </code></pre>
          </div>

          <!-- Client -->
          <div class="card">
            <h3>5. Клиент (Client)</h3>
            <p>
              Работи както с колекцията, така и с итератора само чрез техните интерфейси. Няма нужда
              да знае структурата на колекцията.
            </p>
            <pre><code>
client():
    collection = new ConcreteCollection()
    collection.add("A")
    collection.add("B")
    collection.add("C")

    iterator = collection.createIterator()

    while iterator.hasNext():
        print(iterator.next())
    </code></pre>
          </div>
        </div>

        <h3>Обобщена последователност</h3>
        <div class="sequence">
          <div class="step">
            <strong>1.</strong> Клиентът създава конкретна колекция и добавя елементи.
          </div>
          <div class="step">
            <strong>2.</strong> Клиентът извиква <code>createIterator()</code> от колекцията.
          </div>
          <div class="step"><strong>3.</strong> Колекцията връща нов конкретен итератор.</div>
          <div class="step">
            <strong>4.</strong> Клиентът започва обхождането чрез <code>hasNext()</code> и
            <code>next()</code>.
          </div>
          <div class="step"><strong>5.</strong> Итераторът проследява текущата позиция сам.</div>
          <div class="step">
            <strong>6.</strong> Обхождането завършва, когато <code>hasNext()</code> върне
            <code>false</code>.
          </div>
        </div>

        <h2>Пример на PHP</h2>

        <div class="code-block">
          <span class="comment">// Интерфейс на Итератора</span>
          <span class="keyword">interface</span> <span class="obj">IteratorInterface</span> {
          <span class="keyword">public function</span> current();
          <span class="keyword">public function</span> next();
          <span class="keyword">public function</span> hasNext(): <span class="obj">bool</span>; }

          <span class="comment">// Конкретен Итератор</span>
          <span class="keyword">class</span> <span class="obj">NameIterator</span>
          <span class="keyword">implements</span> <span class="obj">IteratorInterface</span> {
          <span class="keyword">private</span> <span class="obj">array</span> $names;
          <span class="keyword">private</span> <span class="obj">int</span> $pos =
          <span class="str">0</span>;

          <span class="keyword">public function</span> __construct(<span class="obj">array</span>
          $n) { $this->names = $n; }

          <span class="keyword">public function</span> current() {
          <span class="keyword">return</span> $this->names[$this->pos]; }

          <span class="keyword">public function</span> next() { $this->pos++; }

          <span class="keyword">public function</span> hasNext(): <span class="obj">bool</span> {
          <span class="keyword">return</span> $this->pos &lt; count($this->names); } }

          <span class="comment">// Колекция</span>
          <span class="keyword">class</span> <span class="obj">NameCollection</span> {
          <span class="keyword">private</span> <span class="obj">array</span> $data = [];

          <span class="keyword">public function</span> addName(<span class="obj">string</span> $n) {
          $this->data[] = $n; }

          <span class="keyword">public function</span> getIterator():
          <span class="obj">IteratorInterface</span> { <span class="keyword">return new</span>
          <span class="obj">NameIterator</span>($this->data); } }

          <span class="comment">// Клиент (демонстрация)</span>
          $col = <span class="keyword">new</span> <span class="obj">NameCollection</span>();
          $col-&gt;addName(<span class="str">"Иван"</span>); $col-&gt;addName(<span class="str"
            >"Мария"</span
          >); $col-&gt;addName(<span class="str">"Петър"</span>); $it = $col-&gt;getIterator();

          <span class="keyword">while</span> ($it-&gt;hasNext()) {
          <span class="keyword">echo</span> $it-&gt;current() .
          <span class="str">"&lt;br&gt;"</span>; $it-&gt;next(); }
        </div>

        <h3>Примерен изход</h3>
        <div
          class="output-box"
          style="background: #fff; border: 1px solid #ccc; padding: 12px; font-family: Arial"
        >
          Иван<br />
          Мария<br />
          Петър
        </div>

        <h2>Приложимост</h2>
        <div class="cards-container">
          <div class="card">
            <h3>1. Когато колекцията има сложна вътрешна структура</h3>
            <p>
              Използваме <strong>Iterator</strong>, когато нашата колекция е изградена върху сложни
              структури като дървета, графи или стекове, но искаме да скрием тази сложност от
              клиента.
            </p>
            <p>
              Итераторът предоставя опростен интерфейс за последователен достъп до елементите, като
              същевременно предпазва вътрешната структура от неправилна или нежелана намеса.
            </p>
          </div>

          <div class="card">
            <h3>2. Когато искаме да избегнем дублиране на логика за обхождане</h3>
            <p>
              Алгоритмите за обхождане често са обемни и замърсяват бизнес логиката на приложението.
              Преместването им в отделни итераторни класове прави кода по-чист, подреден и по-лесен
              за поддръжка.
            </p>
          </div>

          <div class="card">
            <h3>3. Когато трябва да обхождаме различни типове колекции</h3>
            <p>
              Използваме Iterator, когато искаме кодът ни да работи с различни видове колекции, без
              да зависи от конкретната им реализация.
            </p>
            <p>
              Общите интерфейси за колекции и итератори позволяват лесна подмяна на структурата или
              алгоритъма за обхождане, без да променяме клиентския код.
            </p>
          </div>
        </div>
      </main>
    </div>
  </body>
</html>
